#ifndef INCLUDED_SUBSCRIBER
#define INCLUDED_SUBSCRIBER


#include <condition_variable>
#include <functional>
#include <list>
#include <map>
#include <mutex>
#include <string>
#include <vector>
#include <thread>
#include <iostream>

#include "event.h"
// #include "stream.h"

typedef unsigned long sub_id;
typedef unsigned long stream_id;

/*
 * Subscriber Event
 * Defines a class that allows a stream to pass an event
 * (usually a new data item) to a subscriber
 */
class subscriber_event {

public:
    // structure that indicates the type of data being passed to the subscriber
    enum message_type {
        BOOL  = 0,
        INT   = 1,
        FLOAT = 2,
        STR   = 3
    };

private:
    // structure to hold the data being passed to the subscriber
    union message_data {
        bool        b;
        int         i;
        float       f;
        std::string s;

    public:
        // constructors for supported types
        message_data() {};
        message_data(bool _b) : b(_b) {};
        message_data(int _i) : i(_i) {};
        message_data(float _f) : f(_f) {};
        message_data(std::string _s) : s(_s) {};
        ~message_data(){};

    }; // end message_data


private:
    // class variables to represent the type and data being passed
    message_type type;
    message_data data;

public:
    // constructors for supported types
    // set the correct member of the enum and assign the correct selector
    subscriber_event(bool _b) : type(message_type::BOOL), data(_b) {};
    subscriber_event(int _i) : type(message_type::INT), data(_i) {};
    subscriber_event(float _f) : type(message_type::FLOAT), data(_f) {};
    subscriber_event(std::string _s) : type(message_type::STR), data(_s) {};

    // copy constructor
    subscriber_event(const subscriber_event &event);

public:
    // accessors
    message_type get_type() { return type; }
    bool         get_b() { return data.b; }
    int          get_i() { return data.i; }
    float        get_f() { return data.f; }
    std::string  get_s() { return data.s; }

}; // end subscriber_event


/*
 * Subscriber
 * Defines a class that acts on events generated by a data stream,
 * deal with errors and handle stream termination
 */
template <typename T>
class subscriber {
private:
    static sub_id usub_id;

public:
    // unique identifier for subscriber
    sub_id id;
    
    // function that is called when the stream generates new data
    std::function<void(event<T>)> on_next;

    // function that is called when the stream encounters an error
    std::function<void(std::exception)> on_error;

    // function that is called when the stream is done producing data
    std::function<void()> on_completed;


public:
    static void simple_on_next(event<T> n);

    static void simple_on_error(std::exception e);

    static void simple_on_completed();

public:
    // constructor only requires an on_next function
    subscriber(
        std::function<void(event<T>)> next,
        std::function<void(std::exception)> error = simple_on_error,
        std::function<void()> completed = simple_on_completed);

    // copy constructor
    subscriber(const subscriber &sub);
    subscriber& operator=(subscriber &sub);

    // move constructor
    subscriber(subscriber &&sub);

}; // end subscriber


/*
 * Subscriber Pool
 * Defines a class that maintains a pool of threads that are used to handle
 * messages passed to subscribers that have been registered with this pool
 */
template <typename T>
class subscriber_pool {

private:
    // wrapper class to store the subscriber_event and subscriber_id to 
    // which the event is related
    class queue_event {
    public:
        sub_id           s_id;
        event<T>         s_event;
        queue_event(sub_id _id, event<T> _event) : s_id(_id), s_event(_event) {};
    };

    bool                                   end = false; // tells threads when to exit
    sub_id                                 id = 0; // used for sequentially registering subscribers with unique ids
    std::map<sub_id, subscriber<T>&>       subscribers; // maintains a map of subscribers for fast lookup
    std::list<queue_event>                 events; // list of events to be processed
    std::mutex                             e_lock; // used to syncronize access to list
    std::condition_variable                e_cond; // used to let worker threads sleep
    std::mutex                             sub_lock; // used to synchronize access to the subscriber map
    std::vector<std::thread>               pool; // maintains a list of runnning threads

    std::map<stream_id, std::vector<sub_id>>  stream_subs;

    // function passed to threads to handle subscriber_events
    void handle_event();
public:

    // constructor with default concurrency level set to 1
    subscriber_pool(int concurrency = 1);
    ~subscriber_pool();

    // called to pass a new subscriber_event to subscriber given by sub_id
    void notify(sub_id id, event<T> event);
    void notify_all(std::vector<sub_id>& ids, event<T> event);
    void notify_stream(stream_id str_id, event<T> event);

    // used to notify a subscriber when a stream encounters an exception
    void error(sub_id id, std::exception e);

    // used to notify a subscriber that a stream has ended
    void complete(sub_id id);

    // used to register a subscriber with the current subscriber_pool
    void register_subscriber(subscriber<T> sub);
    void register_subscriber(subscriber<T> sub, stream_id id);

};

#endif